{"version":3,"sources":["entities/task/ui/task-card/index.tsx","entities/task/ui/task-row/index.tsx","shared/api/typicode/base.ts","shared/api/typicode/tasks.ts","entities/task/model/tasks.ts","entities/task/lib.ts","entities/task/ui/task-card/styles.module.scss","entities/task/ui/task-row/styles.module.scss","features/toggle-task/model/toggle-task.ts","features/toggle-task/ui.tsx","pages/tasks-list/styles.module.scss","features/tasks-filters/config.ts","features/tasks-filters/ui.tsx","pages/tasks-list/index.tsx"],"names":["TaskCard","data","titleHref","children","cardProps","loading","title","id","className","styles","root","to","TaskRow","before","cn","completed","apiInstance","axios","create","baseURL","API_URL","BASE_URL","getTasksList","params","get","getTaskById","taskId","setQueryConfig","createEvent","getTasksListFx","createEffect","typicodeApi","tasks","getTaskByIdFx","taskSchema","schema","Entity","normalizeTask","normalize","normalizeTasks","tasksInitialState","$tasks","createStore","on","doneData","_","payload","entities","state","$queryConfig","$tasksListLoading","pending","$taskDetailsLoading","$tasksList","combine","Object","values","$tasksFiltered","tasksList","config","filter","task","undefined","$tasksListEmpty","map","list","length","events","effects","selectors","useTask","useStore","getTaskStatus","module","exports","toggleTask","taskModel","produce","draft","ToggleTask","withStatus","status","taskLib","onClick","toggleTaskModel","checked","filters","filtersList","TasksFilters","reflect","view","onFilterClick","Group","defaultValue","buttonStyle","Button","getFilterById","value","disabled","bind","TasksList","span","source","mapItem","PageContent","variant","isLoading","isEmpty","cases","size","empty","description","ready","hooks","mounted","prepend","TasksListPage","toolbar","justify","Title","level","Content","content","gutter"],"mappings":"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","file":"static/js/5.0145c855.chunk.js","sourcesContent":["import type { PropsWithChildren } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { Card } from \"shared/ui\";\nimport styles from \"./styles.module.scss\";\n\nexport type TaskCardProps = PropsWithChildren<{\n    data?: import(\"shared/api\").Task;\n    titleHref?: string;\n}> & import(\"antd\").CardProps;\n\nexport const TaskCard = ({ data, titleHref, children, ...cardProps }: TaskCardProps) => {\n    if (!data && !cardProps.loading) return null;\n\n    return (\n        <Card\n            title={`Task#${cardProps.loading ? \"\" : data?.id}`}\n            className={styles.root}\n            {...cardProps}\n        >\n            {titleHref ? <Link to={titleHref}>{data?.title}</Link> : data?.title}\n            {children}\n        </Card>\n    );\n};\n","import type { PropsWithChildren, ReactNode } from \"react\";\nimport cn from \"classnames\";\nimport { Link } from \"react-router-dom\";\nimport { Row } from \"shared/ui\";\nimport styles from \"./styles.module.scss\";\n\nexport type TaskRowProps = PropsWithChildren<{\n    data: import(\"shared/api\").Task;\n    titleHref?: string;\n    before?: ReactNode;\n}>;\n\nexport const TaskRow = ({ data, before, titleHref }: TaskRowProps) => {\n    const title = titleHref ? <Link to={titleHref}>{data.title}</Link> : data.title\n\n    return (\n        <Row className={cn(styles.root, { [styles.completed]: data.completed })}>\n            {before}\n            {title}\n        </Row>\n    )\n}\n","import axios from \"axios\";\nimport { API_URL } from \"shared/config\";\n\n// Potentially, you could pass an accessToken\nexport const apiInstance = axios.create({\n    baseURL: API_URL\n});\n","import type { AxiosPromise } from \"axios\";\nimport { apiInstance } from \"./base\";\nimport type { Task } from \"./models\";\n\nconst BASE_URL = \"/todos\"\n\nexport type GetTasksListParams = {\n    userId?: number;\n    completed?: boolean;\n};\n\nexport const getTasksList = (params?: GetTasksListParams): AxiosPromise<Task[]> => {\n    return apiInstance.get(BASE_URL, { params });\n};\n\nexport type GetTaskByIdParams = {\n    taskId: number;\n    [x: string]: any;\n};\n\nexport const getTaskById = ({ taskId, ...params }: GetTaskByIdParams): AxiosPromise<Task> => {\n    return apiInstance.get(`${BASE_URL}/${taskId}`, { params });\n};\n","import { createStore, combine, createEffect, createEvent } from \"effector\";\nimport { useStore } from \"effector-react\";\nimport { normalize, schema } from \"normalizr\";\n\nimport { typicodeApi } from \"shared/api\";\nimport type { Task } from \"shared/api\";\n\nexport type QueryConfig = {\n  completed?: boolean;\n  userId?: number;\n};\n\n\nconst setQueryConfig = createEvent<QueryConfig>();\n\n\n// Each effect can also have its own additional processing\nconst getTasksListFx = createEffect((params?: typicodeApi.tasks.GetTasksListParams) => {\n  return typicodeApi.tasks.getTasksList(params);\n});\nconst getTaskByIdFx = createEffect((params: typicodeApi.tasks.GetTaskByIdParams) => {\n  return typicodeApi.tasks.getTaskById(params);\n});\n\n\n// It is possible to bring normalization to the API level\nexport const taskSchema = new schema.Entity(\"tasks\");\nexport const normalizeTask = (data: Task) => normalize(data, taskSchema);\nexport const normalizeTasks = (data: Task[]) => normalize(data, [taskSchema]);\n\n\n// It is not critical within the demo, but you can also store it as an array without normalization\nexport const tasksInitialState: Record<number, Task> = {};\nexport const $tasks = createStore(tasksInitialState)\n  .on(getTasksListFx.doneData, (_, payload) => normalizeTasks(payload.data).entities.tasks)\n  .on(getTaskByIdFx.doneData, (state, payload) => ({\n    ...state,\n    ...normalizeTask(payload.data).entities.tasks,\n  }))\n\n\n// You can put it in a separate directory (for storing multiple models)\nexport const $queryConfig = createStore<QueryConfig>({})\n  .on(setQueryConfig, (_, payload) => payload)\n\n// You can add potentially debounceable logic\nexport const $tasksListLoading = getTasksListFx.pending;\nexport const $taskDetailsLoading = getTaskByIdFx.pending;\n\n\n/**\n * \"List\" of tasks\n */\nexport const $tasksList = combine($tasks, (tasks) => Object.values(tasks));\n\n/**\n * Filtered tasks\n * @remark It is possible to handle it at the effect level - but then you need to plug additional logic into the store\n * > For example, hide/show task at `toggleTask` event\n */\nexport const $tasksFiltered = combine(\n  $tasksList,\n  $queryConfig,\n  (tasksList, config) => {\n    return tasksList.filter(task => (\n      config.completed === undefined ||\n      task.completed === config.completed\n  ))},\n);\n\nexport const $tasksListEmpty = $tasksFiltered.map((list) => list.length === 0);\n\n// If desired, you can have a separate selector that is not tied to react bindings\nconst useTask = (taskId: number): import(\"shared/api\").Task | undefined => {\n  return useStore($tasks)[taskId];\n};\n\nexport const events = { setQueryConfig };\n\nexport const effects = {\n  getTaskByIdFx,\n  getTasksListFx,\n};\n\nexport const selectors = {\n  useTask,\n};\n","import type { Task } from \"shared/api\";\n\nexport const getTaskStatus = (data: Task) => {\n    return data.completed ? \"CLOSED\" : \"OPENED\";\n};\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"styles_root__1Slir\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"styles_root__fGMdR\",\"completed\":\"styles_completed__2aSOy\"};","import { createEvent } from \"effector\";\nimport produce from \"immer\";\n\nimport { taskModel } from \"entities/task\";\n\nconst toggleTask = createEvent<number>();\n\ntaskModel.$tasks.on(toggleTask, (state, taskId) =>\n  produce(state, (draft) => {\n    const task = draft[taskId];\n    task.completed = !task.completed;\n  })\n);\n\nexport const events = { toggleTask };\n","import { Checkbox } from \"shared/ui\";\nimport { taskModel, taskLib } from \"entities/task\";\nimport * as toggleTaskModel from \"./model\";\n\nexport type ToggleTaskProps = {\n    taskId: number;\n    withStatus?: boolean;\n}\n\n// resolve / unresolve\nexport const ToggleTask = ({ taskId, withStatus = true }: ToggleTaskProps) => {\n    const task = taskModel.selectors.useTask(taskId);\n\n    if (!task) return null;\n\n    const status = taskLib.getTaskStatus(task);\n\n    return (\n        <Checkbox\n            onClick={() => toggleTaskModel.events.toggleTask(taskId)}\n            checked={task.completed}\n        >\n            {withStatus && status}\n        </Checkbox>\n    )\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"styles_root__3vhW2\",\"toolbar\":\"styles_toolbar__2OJM3\",\"content\":\"styles_content__1K7j8\"};","export type Filter = {\n    id: number;\n    title: string;\n    config: import(\"entities/task\").taskModel.QueryConfig;\n}\n\n// We describe here the dataset of \"Closed\" / \"Open\" filters, etc.\nexport const filters: Record<number, Filter> = {\n    1: {\n        id: 1,\n        title: \"All\",\n        config: {},\n    },\n    2: {\n        id: 2,\n        title: \"Opened\",\n        config: { completed: false },\n    },\n    3: {\n        id: 3,\n        title: \"Closed\",\n        config: { completed: true },\n    },\n};\n\nexport const DEFAULT_FILTER = 1;\n\nexport const filtersList = Object.values(filters);\n\nexport const getFilterById = (id: number) => filters[id];\n","import { reflect } from \"@effector/reflect\";\n\nimport { Radio } from \"shared/ui\";\nimport { taskModel } from \"entities/task\";\nimport { filtersList, getFilterById, DEFAULT_FILTER } from \"./config\";\n\ntype Props = {\n  loading: boolean;\n  onFilterClick: (p: taskModel.QueryConfig) => void;\n};\n\nconst View = ({ loading, onFilterClick }: Props) => {\n  return (\n    <Radio.Group defaultValue={DEFAULT_FILTER} buttonStyle=\"solid\">\n      {filtersList.map(({ title, id }) => (\n        <Radio.Button\n          key={id}\n          onClick={() => onFilterClick(getFilterById(id).config)}\n          value={id}\n          disabled={loading}\n        >\n          {title}\n        </Radio.Button>\n      ))}\n    </Radio.Group>\n  );\n};\n\n// The use of effector-reflect here is optional and not critical within the methodology\nexport const TasksFilters = reflect({\n  view: View,\n  bind: {\n    loading: taskModel.$tasksListLoading,\n    onFilterClick: taskModel.events.setQueryConfig,\n  },\n});\n","import { Layout, Row, Col, Typography, Spin, Empty } from \"shared/ui\";\nimport { variant, list } from \"@effector/reflect\";\nimport { combine } from \"effector\";\n\nimport { TasksFilters } from \"features/tasks-filters\";\nimport { ToggleTask } from \"features/toggle-task\";\nimport { TaskRow, taskModel } from \"entities/task\";\nimport styles from \"./styles.module.scss\";\n\nconst TasksListPage = () => {\n  return (\n    <Layout className={styles.root}>\n      <Layout className={styles.toolbar}>\n        {/* ~ Layout.Toolbar */}\n        <Row justify=\"center\">\n          <Typography.Title level={1}>Tasks List</Typography.Title>\n        </Row>\n        <Row justify=\"center\">\n          <TasksFilters />\n        </Row>\n      </Layout>\n      <Layout.Content className={styles.content}>\n        <Row gutter={[0, 20]} justify=\"center\">\n          <PageContent />\n        </Row>\n      </Layout.Content>\n    </Layout>\n  );\n};\n\nconst ListItemView: React.FC<{ task: import(\"shared/api\").Task }> = ({ task }) => {\n  return (\n    <Col key={task.id} span={24}>\n      <TaskRow\n        data={task}\n        titleHref={`/${task.id}`}\n        before={<ToggleTask taskId={task.id} withStatus={false} />}\n      />\n    </Col>\n  );\n};\n\n// The use of effector-reflect here is optional and not critical within the methodology\nconst TasksList = list({\n  view: ListItemView,\n  source: taskModel.$tasksFiltered,\n  bind: {},\n  mapItem: {\n    task: (task) => task,\n  },\n});\n\n// The use of effector-reflect here is optional and not critical within the methodology\nconst PageContent = variant({\n  source: combine(\n    {\n      isLoading: taskModel.$tasksListLoading,\n      isEmpty: taskModel.$tasksListEmpty,\n    },\n    ({ isLoading, isEmpty }) => {\n      if (isLoading) return \"loading\";\n      if (isEmpty) return \"empty\";\n      return \"ready\";\n    }\n  ),\n  cases: {\n    loading: () => <Spin size=\"large\" />,\n    empty: () => <Empty description=\"No tasks found\" />,\n    ready: TasksList,\n  },\n  hooks: {\n    mounted: taskModel.effects.getTasksListFx.prepend(() => {}),\n  },\n});\n\nexport default TasksListPage;\n"],"sourceRoot":""}