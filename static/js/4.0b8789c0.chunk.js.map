{"version":3,"sources":["entities/task/ui/task-card/index.tsx","entities/task/ui/task-row/index.tsx","shared/api/typicode/base.ts","shared/api/typicode/tasks.ts","entities/task/model/tasks.ts","entities/task/lib.ts","entities/task/ui/task-card/styles.module.scss","entities/task/ui/task-row/styles.module.scss","features/toggle-task/model/toggle-task.ts","features/toggle-task/ui.tsx","pages/task-details/styles.module.scss","pages/task-details/index.tsx"],"names":["TaskCard","data","titleHref","children","cardProps","loading","title","id","className","styles","root","to","TaskRow","before","cn","completed","apiInstance","axios","create","baseURL","API_URL","BASE_URL","getTasksList","params","get","getTaskById","taskId","setQueryConfig","createEvent","getTasksListFx","createEffect","typicodeApi","tasks","getTaskByIdFx","taskSchema","schema","Entity","normalizeTask","normalize","normalizeTasks","tasksInitialState","$tasks","createStore","on","doneData","_","payload","entities","state","$queryConfig","$tasksListLoading","pending","$taskDetailsLoading","$tasksList","combine","Object","values","$tasksFiltered","tasksList","config","filter","task","undefined","$tasksListEmpty","map","list","length","events","effects","selectors","useTask","useStore","getTaskStatus","module","exports","toggleTask","taskModel","produce","draft","ToggleTask","withStatus","status","taskLib","onClick","toggleTaskModel","checked","TaskDetailsPage","reflect","view","match","isLoading","Number","useEffect","Content","content","size","card","bodyStyle","height","extra","actions","subTitle","type","bind"],"mappings":"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","file":"static/js/4.0b8789c0.chunk.js","sourcesContent":["import type { PropsWithChildren } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { Card } from \"shared/ui\";\nimport styles from \"./styles.module.scss\";\n\nexport type TaskCardProps = PropsWithChildren<{\n    data?: import(\"shared/api\").Task;\n    titleHref?: string;\n}> & import(\"antd\").CardProps;\n\nexport const TaskCard = ({ data, titleHref, children, ...cardProps }: TaskCardProps) => {\n    if (!data && !cardProps.loading) return null;\n\n    return (\n        <Card\n            title={`Task#${cardProps.loading ? \"\" : data?.id}`}\n            className={styles.root}\n            {...cardProps}\n        >\n            {titleHref ? <Link to={titleHref}>{data?.title}</Link> : data?.title}\n            {children}\n        </Card>\n    );\n};\n","import type { PropsWithChildren, ReactNode } from \"react\";\nimport cn from \"classnames\";\nimport { Link } from \"react-router-dom\";\nimport { Row } from \"shared/ui\";\nimport styles from \"./styles.module.scss\";\n\nexport type TaskRowProps = PropsWithChildren<{\n    data: import(\"shared/api\").Task;\n    titleHref?: string;\n    before?: ReactNode;\n}>;\n\nexport const TaskRow = ({ data, before, titleHref }: TaskRowProps) => {\n    const title = titleHref ? <Link to={titleHref}>{data.title}</Link> : data.title\n\n    return (\n        <Row className={cn(styles.root, { [styles.completed]: data.completed })}>\n            {before}\n            {title}\n        </Row>\n    )\n}\n","import axios from \"axios\";\nimport { API_URL } from \"shared/config\";\n\n// Potentially, you could pass an accessToken\nexport const apiInstance = axios.create({\n    baseURL: API_URL\n});\n","import type { AxiosPromise } from \"axios\";\nimport { apiInstance } from \"./base\";\nimport type { Task } from \"./models\";\n\nconst BASE_URL = \"/todos\"\n\nexport type GetTasksListParams = {\n    userId?: number;\n    completed?: boolean;\n};\n\nexport const getTasksList = (params?: GetTasksListParams): AxiosPromise<Task[]> => {\n    return apiInstance.get(BASE_URL, { params });\n};\n\nexport type GetTaskByIdParams = {\n    taskId: number;\n    [x: string]: any;\n};\n\nexport const getTaskById = ({ taskId, ...params }: GetTaskByIdParams): AxiosPromise<Task> => {\n    return apiInstance.get(`${BASE_URL}/${taskId}`, { params });\n};\n","import { createStore, combine, createEffect, createEvent } from \"effector\";\nimport { useStore } from \"effector-react\";\nimport { normalize, schema } from \"normalizr\";\n\nimport { typicodeApi } from \"shared/api\";\nimport type { Task } from \"shared/api\";\n\nexport type QueryConfig = {\n  completed?: boolean;\n  userId?: number;\n};\n\n\nconst setQueryConfig = createEvent<QueryConfig>();\n\n\n// Each effect can also have its own additional processing\nconst getTasksListFx = createEffect((params?: typicodeApi.tasks.GetTasksListParams) => {\n  return typicodeApi.tasks.getTasksList(params);\n});\nconst getTaskByIdFx = createEffect((params: typicodeApi.tasks.GetTaskByIdParams) => {\n  return typicodeApi.tasks.getTaskById(params);\n});\n\n\n// It is possible to bring normalization to the API level\nexport const taskSchema = new schema.Entity(\"tasks\");\nexport const normalizeTask = (data: Task) => normalize(data, taskSchema);\nexport const normalizeTasks = (data: Task[]) => normalize(data, [taskSchema]);\n\n\n// It is not critical within the demo, but you can also store it as an array without normalization\nexport const tasksInitialState: Record<number, Task> = {};\nexport const $tasks = createStore(tasksInitialState)\n  .on(getTasksListFx.doneData, (_, payload) => normalizeTasks(payload.data).entities.tasks)\n  .on(getTaskByIdFx.doneData, (state, payload) => ({\n    ...state,\n    ...normalizeTask(payload.data).entities.tasks,\n  }))\n\n\n// You can put it in a separate directory (for storing multiple models)\nexport const $queryConfig = createStore<QueryConfig>({})\n  .on(setQueryConfig, (_, payload) => payload)\n\n// You can add potentially debounceable logic\nexport const $tasksListLoading = getTasksListFx.pending;\nexport const $taskDetailsLoading = getTaskByIdFx.pending;\n\n\n/**\n * \"List\" of tasks\n */\nexport const $tasksList = combine($tasks, (tasks) => Object.values(tasks));\n\n/**\n * Filtered tasks\n * @remark It is possible to handle it at the effect level - but then you need to plug additional logic into the store\n * > For example, hide/show task at `toggleTask` event\n */\nexport const $tasksFiltered = combine(\n  $tasksList,\n  $queryConfig,\n  (tasksList, config) => {\n    return tasksList.filter(task => (\n      config.completed === undefined ||\n      task.completed === config.completed\n  ))},\n);\n\nexport const $tasksListEmpty = $tasksFiltered.map((list) => list.length === 0);\n\n// If desired, you can have a separate selector that is not tied to react bindings\nconst useTask = (taskId: number): import(\"shared/api\").Task | undefined => {\n  return useStore($tasks)[taskId];\n};\n\nexport const events = { setQueryConfig };\n\nexport const effects = {\n  getTaskByIdFx,\n  getTasksListFx,\n};\n\nexport const selectors = {\n  useTask,\n};\n","import type { Task } from \"shared/api\";\n\nexport const getTaskStatus = (data: Task) => {\n    return data.completed ? \"CLOSED\" : \"OPENED\";\n};\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"styles_root__1Slir\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"styles_root__fGMdR\",\"completed\":\"styles_completed__2aSOy\"};","import { createEvent } from \"effector\";\nimport produce from \"immer\";\n\nimport { taskModel } from \"entities/task\";\n\nconst toggleTask = createEvent<number>();\n\ntaskModel.$tasks.on(toggleTask, (state, taskId) =>\n  produce(state, (draft) => {\n    const task = draft[taskId];\n    task.completed = !task.completed;\n  })\n);\n\nexport const events = { toggleTask };\n","import { Checkbox } from \"shared/ui\";\nimport { taskModel, taskLib } from \"entities/task\";\nimport * as toggleTaskModel from \"./model\";\n\nexport type ToggleTaskProps = {\n    taskId: number;\n    withStatus?: boolean;\n}\n\n// resolve / unresolve\nexport const ToggleTask = ({ taskId, withStatus = true }: ToggleTaskProps) => {\n    const task = taskModel.selectors.useTask(taskId);\n\n    if (!task) return null;\n\n    const status = taskLib.getTaskStatus(task);\n\n    return (\n        <Checkbox\n            onClick={() => toggleTaskModel.events.toggleTask(taskId)}\n            checked={task.completed}\n        >\n            {withStatus && status}\n        </Checkbox>\n    )\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"styles_root__1aFqh\",\"content\":\"styles_content__3IC4G\",\"card\":\"styles_card__hyz1A\"};","import { useEffect } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport { Layout, Result, Button } from \"shared/ui\";\nimport { reflect } from \"@effector/reflect\";\n\nimport { ToggleTask } from \"features/toggle-task\";\nimport { TaskCard, taskModel } from \"entities/task\";\nimport styles from \"./styles.module.scss\";\n\ntype Props = import(\"react-router-dom\").RouteChildrenProps<{\n    taskId: string;\n}> & {\n    isLoading: boolean;\n};\n\nconst View = ({ match, isLoading }: Props) => {\n    const taskId = Number(match?.params.taskId);\n    const task = taskModel.selectors.useTask(taskId);\n\n    useEffect(() => {\n        taskModel.effects.getTaskByIdFx({ taskId });\n    }, [taskId]);\n\n    // You can move some logic to entity/task/card (as a container)\n    if (!task && !isLoading) {\n        return (\n            <Result\n                status=\"404\"\n                title=\"404\"\n                subTitle=\"Task was not found\"\n                extra={<Link to=\"/\"><Button type=\"primary\">Back to tasks list {taskId}</Button></Link>}\n            />\n        )\n    }\n\n    return (\n        <Layout className={styles.root}>\n            <Layout.Content className={styles.content}>\n                <TaskCard\n                    data={task}\n                    size=\"default\"\n                    loading={isLoading}\n                    className={styles.card}\n                    bodyStyle={{ height: 400 }}\n                    extra={<Link to=\"/\">Back to TasksList</Link>}\n                    actions={[\n                        <ToggleTask key=\"toggle\" taskId={taskId} />\n                    ]}\n                />\n            </Layout.Content>\n        </Layout>\n    )\n};\n\n// The use of effector-reflect here is optional and not critical within the methodology\nconst TaskDetailsPage = reflect({\n    view: View,\n    bind: {\n        isLoading: taskModel.$taskDetailsLoading,\n    }\n});\n\nexport default TaskDetailsPage;\n"],"sourceRoot":""}